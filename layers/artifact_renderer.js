/**
 * KURO::ARTIFACTS v1.0 — Server-side Artifact Renderer
 * 
 * Renders model outputs into downloadable artifacts:
 *   - Markdown → HTML → PDF (via puppeteer or wkhtmltopdf)
 *   - CSV → chart preview (SVG)
 *   - Report builder (structured JSON → formatted PDF)
 * 
 * Route: POST /api/artifacts/render
 * 
 * Tier gating:
 *   Free: 3 artifacts/day, markdown only
 *   Pro: 20 artifacts/day, all formats
 *   Sovereign: unlimited, all formats + custom templates
 */

const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const DATA_DIR = process.env.KURO_DATA || '/var/lib/kuro';
const ARTIFACTS_DIR = path.join(DATA_DIR, 'artifacts');

if (!fs.existsSync(ARTIFACTS_DIR)) fs.mkdirSync(ARTIFACTS_DIR, { recursive: true });

// ═══ Tier Quotas ═══
const ARTIFACT_QUOTAS = {
  free: { daily: 3, formats: ['markdown'] },
  pro: { daily: 20, formats: ['markdown', 'csv', 'report'] },
  sovereign: { daily: 999, formats: ['markdown', 'csv', 'report', 'custom'] }
};

const artifactUsage = new Map();

function checkArtifactQuota(userId, tier) {
  const quota = ARTIFACT_QUOTAS[tier] || ARTIFACT_QUOTAS.free;
  const today = new Date().toISOString().slice(0, 10);
  let entry = artifactUsage.get(userId);
  if (!entry || entry.date !== today) {
    entry = { count: 0, date: today };
    artifactUsage.set(userId, entry);
  }
  if (entry.count >= quota.daily) {
    return { allowed: false, reason: 'daily_limit_reached' };
  }
  return { allowed: true, remaining: quota.daily - entry.count, formats: quota.formats };
}

function consumeArtifactQuota(userId) {
  const entry = artifactUsage.get(userId);
  if (entry) entry.count++;
}

// ═══ Markdown → HTML ═══
function markdownToHtml(markdown) {
  // Basic markdown to HTML (production: use marked or markdown-it)
  let html = markdown
    .replace(/^### (.+)$/gm, '<h3>$1</h3>')
    .replace(/^## (.+)$/gm, '<h2>$1</h2>')
    .replace(/^# (.+)$/gm, '<h1>$1</h1>')
    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
    .replace(/\*(.+?)\*/g, '<em>$1</em>')
    .replace(/`(.+?)`/g, '<code>$1</code>')
    .replace(/^- (.+)$/gm, '<li>$1</li>')
    .replace(/\n\n/g, '</p><p>')
    .replace(/\n/g, '<br>');
  
  // Wrap lists
  html = html.replace(/(<li>.+?<\/li>(\s*<br>)*)+/g, (match) => `<ul>${match}</ul>`);
  
  return `<!DOCTYPE html>
<html><head>
<meta charset="utf-8">
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; max-width: 800px; margin: 40px auto; padding: 0 20px; line-height: 1.6; color: #1a1a1a; }
  h1 { border-bottom: 2px solid #a855f7; padding-bottom: 8px; }
  h2 { color: #6b21a8; }
  code { background: #f3f4f6; padding: 2px 6px; border-radius: 4px; font-size: 0.9em; }
  pre code { display: block; padding: 16px; overflow-x: auto; }
  table { border-collapse: collapse; width: 100%; margin: 16px 0; }
  th, td { border: 1px solid #d1d5db; padding: 8px 12px; text-align: left; }
  th { background: #f9fafb; font-weight: 600; }
  .kuro-footer { margin-top: 40px; padding-top: 16px; border-top: 1px solid #e5e7eb; font-size: 0.8em; color: #9ca3af; }
</style>
</head><body>
<p>${html}</p>
<div class="kuro-footer">Generated by KURO OS • ${new Date().toISOString().slice(0, 10)}</div>
</body></html>`;
}

// ═══ CSV → Chart SVG ═══
function csvToChartSvg(csvContent, opts = {}) {
  const lines = csvContent.trim().split('\n');
  if (lines.length < 2) return { error: 'CSV needs at least header + 1 row' };
  
  const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
  const rows = lines.slice(1).map(l => l.split(',').map(c => c.trim().replace(/"/g, '')));
  
  // Find numeric columns
  const numericCols = headers.map((_, i) => rows.every(r => !isNaN(parseFloat(r[i]))));
  const firstNumericIdx = numericCols.indexOf(true);
  
  if (firstNumericIdx === -1) {
    return { error: 'No numeric columns found for charting' };
  }
  
  const labels = rows.map(r => r[0]);
  const values = rows.map(r => parseFloat(r[firstNumericIdx]));
  const maxVal = Math.max(...values);
  const minVal = Math.min(0, Math.min(...values));
  const range = maxVal - minVal || 1;
  
  const width = 600;
  const height = 400;
  const padding = { top: 40, right: 20, bottom: 60, left: 60 };
  const chartWidth = width - padding.left - padding.right;
  const chartHeight = height - padding.top - padding.bottom;
  
  const barWidth = Math.min(40, chartWidth / labels.length - 4);
  
  let bars = '';
  labels.forEach((label, i) => {
    const x = padding.left + (i * (chartWidth / labels.length)) + (chartWidth / labels.length - barWidth) / 2;
    const barHeight = ((values[i] - minVal) / range) * chartHeight;
    const y = padding.top + chartHeight - barHeight;
    
    bars += `<rect x="${x}" y="${y}" width="${barWidth}" height="${barHeight}" fill="#a855f7" rx="2"/>`;
    bars += `<text x="${x + barWidth/2}" y="${height - padding.bottom + 15}" text-anchor="middle" font-size="10" fill="#6b7280" transform="rotate(-45 ${x + barWidth/2} ${height - padding.bottom + 15})">${label.slice(0, 12)}</text>`;
    bars += `<text x="${x + barWidth/2}" y="${y - 5}" text-anchor="middle" font-size="9" fill="#374151">${values[i]}</text>`;
  });
  
  const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${width} ${height}" width="${width}" height="${height}">
  <rect width="${width}" height="${height}" fill="white" rx="8"/>
  <text x="${width/2}" y="24" text-anchor="middle" font-size="14" font-weight="bold" fill="#111827">${opts.title || headers[firstNumericIdx]}</text>
  <line x1="${padding.left}" y1="${padding.top + chartHeight}" x2="${width - padding.right}" y2="${padding.top + chartHeight}" stroke="#e5e7eb" stroke-width="1"/>
  ${bars}
</svg>`;
  
  return { svg, type: 'bar_chart', columns: headers, rows: rows.length };
}

// ═══ Report Builder ═══
function buildReport(reportData) {
  const { title, sections, author, date } = reportData;
  
  let markdown = `# ${title || 'Report'}\n\n`;
  if (author) markdown += `*Author: ${author}*  \n`;
  markdown += `*Date: ${date || new Date().toISOString().slice(0, 10)}*\n\n---\n\n`;
  
  if (sections && Array.isArray(sections)) {
    for (const section of sections) {
      markdown += `## ${section.heading || 'Section'}\n\n`;
      if (section.content) markdown += `${section.content}\n\n`;
      if (section.table) {
        const headers = Object.keys(section.table[0] || {});
        markdown += `| ${headers.join(' | ')} |\n`;
        markdown += `| ${headers.map(() => '---').join(' | ')} |\n`;
        for (const row of section.table) {
          markdown += `| ${headers.map(h => row[h] || '').join(' | ')} |\n`;
        }
        markdown += '\n';
      }
    }
  }
  
  return markdownToHtml(markdown);
}

// ═══ Render Function ═══
/**
 * @param {string} type - 'markdown' | 'csv' | 'report'
 * @param {string|object} content - Raw content or structured data
 * @param {object} opts - { title, outputFormat }
 * @returns {object} { artifactId, filePath, mimeType, size }
 */
function render(type, content, opts = {}) {
  const artifactId = crypto.randomBytes(8).toString('hex');
  let html, filePath, mimeType;
  
  switch(type) {
    case 'markdown': {
      html = markdownToHtml(content);
      filePath = path.join(ARTIFACTS_DIR, `${artifactId}.html`);
      fs.writeFileSync(filePath, html);
      mimeType = 'text/html';
      
      // Try to convert to PDF if wkhtmltopdf available
      if (opts.outputFormat === 'pdf') {
        try {
          const pdfPath = path.join(ARTIFACTS_DIR, `${artifactId}.pdf`);
          execSync(`wkhtmltopdf --quiet "${filePath}" "${pdfPath}"`, { timeout: 15000 });
          filePath = pdfPath;
          mimeType = 'application/pdf';
        } catch(e) {
          // HTML fallback is fine
        }
      }
      break;
    }
    
    case 'csv': {
      const chart = csvToChartSvg(content, opts);
      if (chart.error) return { error: chart.error };
      filePath = path.join(ARTIFACTS_DIR, `${artifactId}.svg`);
      fs.writeFileSync(filePath, chart.svg);
      mimeType = 'image/svg+xml';
      break;
    }
    
    case 'report': {
      html = buildReport(typeof content === 'string' ? JSON.parse(content) : content);
      filePath = path.join(ARTIFACTS_DIR, `${artifactId}.html`);
      fs.writeFileSync(filePath, html);
      mimeType = 'text/html';
      break;
    }
    
    default:
      return { error: `Unknown artifact type: ${type}` };
  }
  
  const size = fs.statSync(filePath).size;
  
  return { artifactId, filePath, mimeType, size, type };
}

// ═══ Route Handler ═══
function mountArtifactRoutes(app, logEvent, authMiddleware) {
  const auth = authMiddleware || { required: (q,s,n) => n() };
  
  app.post('/api/artifacts/render', auth.required, (req, res) => {
    try {
      const { type, content, options } = req.body;
      if (!type || !content) return res.status(400).json({ error: 'type and content required' });
      
      const userId = req.user?.userId || 'anonymous';
      const tier = req.user?.tier || 'free';
      
      const quota = checkArtifactQuota(userId, tier);
      if (!quota.allowed) return res.status(403).json({ error: quota.reason });
      if (!quota.formats.includes(type)) return res.status(403).json({ error: `Format '${type}' not available on your tier`, available: quota.formats });
      
      const result = render(type, content, options || {});
      if (result.error) return res.status(400).json({ error: result.error });
      
      consumeArtifactQuota(userId);
      
      logEvent({
        agent: 'artifacts',
        action: 'render',
        userId,
        requestId: req.requestId,
        meta: { type, artifactId: result.artifactId, size: result.size }
      });
      
      res.json({
        success: true,
        artifactId: result.artifactId,
        downloadUrl: `/api/artifacts/download/${result.artifactId}`,
        mimeType: result.mimeType,
        size: result.size,
        remaining: checkArtifactQuota(userId, tier).remaining
      });
    } catch(e) {
      console.error('[ARTIFACTS] Render error:', e.message);
      res.status(500).json({ error: 'Render failed' });
    }
  });
  
  app.get('/api/artifacts/download/:id', (req, res) => {
    const { id } = req.params;
    if (!/^[a-f0-9]{16}$/.test(id)) return res.status(400).json({ error: 'Invalid artifact ID' });
    
    // Find artifact file
    const candidates = fs.readdirSync(ARTIFACTS_DIR).filter(f => f.startsWith(id));
    if (candidates.length === 0) return res.status(404).json({ error: 'Artifact not found' });
    
    const filePath = path.join(ARTIFACTS_DIR, candidates[0]);
    res.sendFile(filePath);
  });
  
  console.log('[ARTIFACTS] Routes mounted');
}

// Cleanup old artifacts (> 24h)
setInterval(() => {
  try {
    const now = Date.now();
    const files = fs.readdirSync(ARTIFACTS_DIR);
    for (const f of files) {
      const fp = path.join(ARTIFACTS_DIR, f);
      const stat = fs.statSync(fp);
      if (now - stat.mtimeMs > 24 * 60 * 60 * 1000) {
        fs.unlinkSync(fp);
      }
    }
  } catch(e) {}
}, 60 * 60 * 1000);

module.exports = {
  mountArtifactRoutes,
  render,
  checkArtifactQuota,
  ARTIFACT_QUOTAS
};
